<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>som算法</title>
    <url>/2019/11/28/som%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p> 生物学研究表明，在人脑的感觉通道上，神经元的组织原理是有序排列的。当外界的特定时空信息输入时，大脑皮层的特定区域兴奋，而且类似的外界信息在对应的区域是连续映像的。生物视网膜中有许多特定的细胞对特定的图形比较敏感，当视网膜中有若干个接收单元同时受特定模式刺激时，就使大脑皮层中的特定神经元开始兴奋，输入模式接近，与之对应的兴奋神经元也接近；在听觉通道上，神经元在结构排列上与频率的关系十分密切，对于某个频率，特定的神经元具有最大的响应，位置相邻的神经元具有相近的频率特征，而远离的神经元具有的频率特征差别也较大。大脑皮层中神经元的这种响应特点不是先天安排好的，而是通过后天的学习自组织形成的 。 在生物神经系统中，存在着一种侧抑制现象，即一个神经细胞兴奋以后，会对周围其他神经细胞产生抑制作用。这种抑制作用会使神经细胞之间出现竞争，其结果是某些获胜，而另一些则失败。表现形式是获胜神经细胞兴奋，失败神经细胞抑制。自组织（竞争型）神经网络就是模拟上述生物神经系统功能的人工神经网络 。</p>
<a id="more"></a>

<h1 id="1-SOM简介"><a href="#1-SOM简介" class="headerlink" title="1.SOM简介"></a>1.SOM简介</h1><p> SOM 即自组织映射，是一种用于特征检测的无监督学习神经网络。它模拟人脑中处于不同区域的神经细胞分工不同的特点，即不同区域具有不同的响应特征，而且这一过程是自动完成的。SOM 用于生成训练样本的低维空间，可以将高维数据间复杂的非线性统计关系转化为简单的几何关系，且以低维的方式展现，因此通常在降维问题中会使用它。 </p>
<p>SOM 与其它人工神经网络不同，因为它们使用的是竞争性学习而不是错误相关的学习，后者涉及到反向传播和梯度下降。在竞争性学习中，各个节点会相互竞争响应输入数据子集的权利。训练数据通常没有标签，映射会学习根据相似度来区分各个特征。 </p>
<h2 id="2-SOM结构"><a href="#2-SOM结构" class="headerlink" title="2 .SOM结构"></a>2 .SOM结构</h2><p>SOM结构如下图,它由输入层和竞争层(输出层)组成。输入层神经元数为 n,竞争层由m个神经元组成的一维或者二维的平面阵列，网络是全连接的即每个输入节点都与所有的输出节点相连接。</p>
<p><img src="https://blog-1300775928.cos.ap-chengdu.myqcloud.com/som%E7%AE%97%E6%B3%95/som.png" alt=""></p>
<h1 id="3-SOM学习过程"><a href="#3-SOM学习过程" class="headerlink" title="3 .SOM学习过程"></a>3 .SOM学习过程</h1><p>SOM是无监督学习, 不需要成对的数据. SOM的学习过程可以总结成一句话, 就是调整输出层权重W以便于让相邻的节点具有相似的权重. 具体来说分为一下的步骤:</p>
<ol>
<li>每个节点的权重都被随机初始化。</li>
<li>从训练数据集中随机选择向量x并将其输入到网格。</li>
<li>检查每个输出层节点以计算哪一个的权重最像输入向量。获胜节点通常被称为最佳匹配单元（BMU）或激活单元。</li>
<li>现在计算BMU邻域节点, 以BMU为圆心, 处于半径R内的节点都被称为邻域。R是一个开始较大的值，通常设置为输出层的“半径”，但会随着训练逐步减小。在该半径内发现的任何节点都被视为在BMU的邻域内。</li>
<li>调整每个邻域节点（步骤4中找到的节点）权重以使它们更像输入向量。节点越靠近BMU，其权重调整的就越大。</li>
<li>N次迭代重复步骤2</li>
</ol>
<h1 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4 .代码实现"></a>4 .代码实现</h1><h2 id="4-1-数据"><a href="#4-1-数据" class="headerlink" title="4.1 数据"></a>4.1 数据</h2><p>数据是地铁隧道监控数据的330测区一段时间的收集的数据。具体数据如下图。</p>
<p><img src="https://blog-1300775928.cos.ap-chengdu.myqcloud.com/som%E7%AE%97%E6%B3%95/%E6%9D%A5%E8%BD%A6%E6%95%B0%E6%8D%AE.png" alt=""></p>
<p>将数据切分为2000份，其中包含来车的波形数据有148份。</p>
<p>4.2 数据特征提取。</p>
<p>这里数据特征提取采用自编码网络。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from keras.models import Model</span><br><span class="line">from keras.layers import Dense, Input</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from keras.optimizers import Adam</span><br><span class="line"></span><br><span class="line">data_in=data</span><br><span class="line">data_label=label</span><br><span class="line"># 建立模型</span><br><span class="line"># in order to plot in a 2D figure</span><br><span class="line">encoding_dim = 2  # encoding_dim，要压缩成的维度。</span><br><span class="line"></span><br><span class="line"># this is our input placeholder</span><br><span class="line">input_img = Input(shape=(1500,))</span><br><span class="line"></span><br><span class="line"># encoder layers</span><br><span class="line">encoded = Dense(512, activation=&apos;relu&apos;)(input_img)</span><br><span class="line">encoded = Dense(128, activation=&apos;relu&apos;)(encoded)</span><br><span class="line">encoded = Dense(32, activation=&apos;relu&apos;)(encoded)</span><br><span class="line">encoder_output = Dense(encoding_dim)(encoded)</span><br><span class="line"></span><br><span class="line"># decoder layers</span><br><span class="line">decoded = Dense(32, activation=&apos;relu&apos;)(encoder_output)</span><br><span class="line">decoded = Dense(128, activation=&apos;relu&apos;)(decoded)</span><br><span class="line">decoded = Dense(512, activation=&apos;relu&apos;)(decoded)</span><br><span class="line">decoded = Dense(1500, activation=&apos;tanh&apos;)(decoded)</span><br><span class="line"></span><br><span class="line"># 接下来直接用 Model 这个模块来组建模型，输入就是2000份波形，输出是解压的最后的结果。</span><br><span class="line"># construct the autoencoder model</span><br><span class="line">autoencoder = Model(input=input_img, output=decoded)</span><br><span class="line"># 当我们想要看由 1500 压缩到 2维后，这个结果是什么样的时候，也可以只单独组建压缩的板块，</span><br><span class="line"># 此时它的输入是[2000,1500]的数组，输出是压缩环节的最后结果。</span><br><span class="line"># construct the encoder model for plotting</span><br><span class="line">encoder = Model(input=input_img, output=encoder_output)</span><br><span class="line"></span><br><span class="line"># 激活模型</span><br><span class="line"># 接下来是编译自编码这个模型，优化器用的是 adam，损失函数用的是 mse。</span><br><span class="line"># compile autoencoder</span><br><span class="line">adam = Adam(lr=1e-4)</span><br><span class="line">autoencoder.compile(optimizer=&apos;adam&apos;, loss=&apos;mse&apos;)</span><br><span class="line"># 训练模型</span><br><span class="line"># training</span><br><span class="line">autoencoder.fit(data_in, data_in,</span><br><span class="line">                nb_epoch=20,</span><br><span class="line">                batch_size=256,</span><br><span class="line">                shuffle=True)</span><br><span class="line"># 可视化结果</span><br><span class="line"># 最后看到可视化的结果，自编码模型可以把这俩类波形给区分开来，</span><br><span class="line"># 我们可以用自编码这个过程来作为一个特征压缩的方法，</span><br><span class="line"># 和PCA的功能一样，效果要比它好一些，因为它是非线性的结构</span><br><span class="line"># plotting</span><br><span class="line">encoded_imgs = encoder.predict(data_in)</span><br><span class="line"># io.savemat(&apos;data2000.mat&apos;,&#123;&apos;data&apos;:encoded_imgs&#125;)</span><br><span class="line">plt.scatter(encoded_imgs[:, 0], encoded_imgs[:, 1], c=label)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>自编码提取的特征如下图：</p>
<p><img src="https://blog-1300775928.cos.ap-chengdu.myqcloud.com/som%E7%AE%97%E6%B3%95/%E8%87%AA%E7%BC%96%E7%A0%81%E7%89%B9%E5%BE%81%E5%8E%8B%E7%BC%A9.jpg" alt=""></p>
<p>4.3 SOM聚类</p>
<p>采用SOM模型对数据聚类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import math</span><br><span class="line"># np.random.seed(1337)</span><br><span class="line"></span><br><span class="line">class SOM(object):</span><br><span class="line">    def __init__(self, X, output, iteration, batch_size):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param X:  形状是N*D， 输入样本有N个,每个D维</span><br><span class="line">        :param output: (n,m)一个元组，为输出层的形状是一个n*m的二维矩阵</span><br><span class="line">        :param iteration:迭代次数</span><br><span class="line">        :param batch_size:每次迭代时的样本数量</span><br><span class="line">        初始化一个权值矩阵，形状为D*(n*m)，即有n*m权值向量，每个D维</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.X = X</span><br><span class="line">        self.output = output</span><br><span class="line">        self.iteration = iteration</span><br><span class="line">        self.batch_size = batch_size</span><br><span class="line">        self.W = np.random.rand(X.shape[1], output[0] * output[1])</span><br><span class="line">        # print (self.W.shape)</span><br><span class="line"></span><br><span class="line">    def GetN(self, t):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param t:时间t, 这里用迭代次数来表示时间</span><br><span class="line">        :return: 返回一个整数，表示拓扑距离，时间越大，拓扑邻域越小</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        a = min(self.output)</span><br><span class="line">        return int(a-float(a)*t/self.iteration)</span><br><span class="line"></span><br><span class="line">    def Geteta(self, t, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param t: 时间t, 这里用迭代次数来表示时间</span><br><span class="line">        :param n: 拓扑距离</span><br><span class="line">        :return: 返回学习率，</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return np.power(np.e, -n)/(t+2)</span><br><span class="line"></span><br><span class="line">    def updata_W(self, X, t, winner):</span><br><span class="line">        N = self.GetN(t)</span><br><span class="line">        for x, i in enumerate(winner):</span><br><span class="line">            to_update = self.getneighbor(i, N)</span><br><span class="line">            for j in range(N+1):</span><br><span class="line">                e = self.Geteta(t, j)</span><br><span class="line">                for w in to_update[j]:</span><br><span class="line">                    self.W[:, w] = np.add(self.W[:,w], e*(X[x,:] - self.W[:,w]))</span><br><span class="line"></span><br><span class="line">    def getneighbor(self, index, N):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param index:获胜神经元的下标</span><br><span class="line">        :param N: 邻域半径</span><br><span class="line">        :return ans: 返回一个集合列表，分别是不同邻域半径内需要更新的神经元坐标</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        a, b = self.output</span><br><span class="line">        length = a*b</span><br><span class="line">        def distence(index1, index2):</span><br><span class="line">            i1_a, i1_b = index1 // a, index1 % b</span><br><span class="line">            i2_a, i2_b = index2 // a, index2 % b</span><br><span class="line">            return np.abs(i1_a - i2_a), np.abs(i1_b - i2_b)</span><br><span class="line"></span><br><span class="line">        ans = [set() for i in range(N+1)]</span><br><span class="line">        for i in range(length):</span><br><span class="line">            dist_a, dist_b = distence(i, index)</span><br><span class="line">            if dist_a &lt;= N and dist_b &lt;= N: ans[max(dist_a, dist_b)].add(i)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def train(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        train_Y:训练样本与形状为batch_size*(n*m)</span><br><span class="line">        winner:一个一维向量，batch_size个获胜神经元的下标</span><br><span class="line">        :return:返回值是调整后的W</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        count = 0</span><br><span class="line">        while self.iteration &gt; count:</span><br><span class="line">            train_X = self.X[np.random.choice(self.X.shape[0], self.batch_size)]</span><br><span class="line">            normal_W(self.W)</span><br><span class="line">            normal_X(train_X)</span><br><span class="line">            train_Y = train_X.dot(self.W)</span><br><span class="line">            winner = np.argmax(train_Y, axis=1).tolist()</span><br><span class="line">            self.updata_W(train_X, count, winner)</span><br><span class="line">            count += 1</span><br><span class="line">            # print(winner)</span><br><span class="line">        return self.W</span><br><span class="line"></span><br><span class="line">    def train_result(self):</span><br><span class="line">        normal_X(self.X)</span><br><span class="line">        train_Y = self.X.dot(self.W)</span><br><span class="line">        # winner = np.argmax(train_Y, axis=1).tolist()</span><br><span class="line">        winner = np.argmax(train_Y, axis=1)</span><br><span class="line">        # print (winner)</span><br><span class="line">        return winner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def normal_X(X):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :param X:二维矩阵，N*D，N个D维的数据</span><br><span class="line">    :return: 将X归一化的结果</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    N, D = X.shape</span><br><span class="line">    for i in range(N):</span><br><span class="line">        temp = np.sum(np.multiply(X[i], X[i]))</span><br><span class="line">        X[i] /= np.sqrt(temp)</span><br><span class="line">    return X</span><br><span class="line">def normal_W(W):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :param W:二维矩阵，D*(n*m)，D个n*m维的数据</span><br><span class="line">    :return: 将W归一化的结果</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    for i in range(W.shape[1]):</span><br><span class="line">        temp = np.sum(np.multiply(W[:,i], W[:,i]))</span><br><span class="line">        W[:, i] /= np.sqrt(temp)</span><br><span class="line">    return W</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data_car=io.loadmat(&apos;data2000.mat&apos;)</span><br><span class="line">data_car_data=data_car[&apos;data&apos;]</span><br><span class="line">data_car_data=np.array(data_car_data)</span><br><span class="line"></span><br><span class="line">size=(10,10)</span><br><span class="line">som = SOM(data_car_data, size, 200, 30)</span><br><span class="line">som.train()</span><br><span class="line">res = som.train_result()</span><br><span class="line"># print(res)</span><br><span class="line">#绘图</span><br><span class="line">data_drow=[]</span><br><span class="line">for i in range(len(res)):</span><br><span class="line">    data_x_y=res[i]</span><br><span class="line">    data_drow.append([math.floor(data_x_y/size[1]),data_x_y%size[1]])</span><br><span class="line">print(data_drow)</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">data_x=[]</span><br><span class="line">data_y=[]</span><br><span class="line">for i in range(len(data_drow)):</span><br><span class="line">    data_x.append(data_drow[i][0])</span><br><span class="line">    data_y.append(data_drow[i][1])</span><br><span class="line"># print(data_x)</span><br><span class="line"># print(data_y)</span><br><span class="line">plt.scatter(data_x, data_y,c=label)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>聚类效果如下图：</p>
<p><img src="https://blog-1300775928.cos.ap-chengdu.myqcloud.com/som%E7%AE%97%E6%B3%95/SOM%E8%81%9A%E7%B1%BB.jpg" alt=""></p>
<p>当然也可以直接将数据传入SOM模型聚类。效果如下图：</p>
<p><img src="https://blog-1300775928.cos.ap-chengdu.myqcloud.com/som%E7%AE%97%E6%B3%95/SOM%E7%9B%B4%E6%8E%A5%E8%81%9A%E7%B1%BB.png" alt=""></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>人脸识别</title>
    <url>/2019/11/25/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p> 人脸识别，是基于人的脸部特征信息进行身份识别的一种生物识别技术。用摄像机或摄像头采集含有人脸的图像或视频流，并自动在图像中检测和跟踪人脸，进而对检测到的人脸进行脸部识别的一系列相关技术，通常也叫做人像识别、面部识别。 </p>
<a id="more"></a>

<h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h1><h2 id="1-1-安装-Anconda，创建新环境。"><a href="#1-1-安装-Anconda，创建新环境。" class="headerlink" title="1.1 安装 Anconda，创建新环境。"></a>1.1 安装 <a href="https://www.jianshu.com/p/742dc4d8f4c5" target="_blank" rel="noopener">Anconda</a>，创建新环境。</h2><h2 id="1-2-安装pycharm"><a href="#1-2-安装pycharm" class="headerlink" title="1.2 安装pycharm"></a>1.2 安装<a href="https://www.runoob.com/w3cnote/pycharm-windows-install.html" target="_blank" rel="noopener">pycharm</a></h2><h2 id="1-2-在新环境中安装-Opencv、os、sleep等第三方包。"><a href="#1-2-在新环境中安装-Opencv、os、sleep等第三方包。" class="headerlink" title="1.2 在新环境中安装 Opencv、os、sleep等第三方包。"></a>1.2 在新环境中安装 Opencv、os、sleep等第三方包。</h2><p><strong>激活新环境，pip 安装第三方包。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install cv2</span><br><span class="line">pip install os</span><br><span class="line">pip install sleep</span><br></pre></td></tr></table></figure>



<h1 id="2-人脸识别流程"><a href="#2-人脸识别流程" class="headerlink" title="2.人脸识别流程"></a>2.人脸识别流程</h1><p>人脸识别系统主要包括四个组成部分，分别为：人脸图像采集及检测、人脸图像预处理、人脸图像特征提取以及匹配与识别。</p>
<h2 id="2-1-人脸图像采集及检测"><a href="#2-1-人脸图像采集及检测" class="headerlink" title="2.1 人脸图像采集及检测"></a>2.1 人脸图像采集及检测</h2><p>人脸图像采集：不同的人脸图像都能通过摄像镜头采集下来，比如静态图像、动态图像、不同的位置、不同表情等方面都可以得到很好的采集。当用户在采集设备的拍摄范围内时，采集设备会自动搜索并拍摄用户的人脸图像。</p>
<p>人脸检测：人脸检测在实际中主要用于人脸识别的预处理，即在图像中准确标定出人脸的位置和大小。人脸图像中包含的模式特征十分丰富，如直方图特征、颜色特征、模板特征、结构特征及Haar特征等。人脸检测就是把这其中有用的信息挑出来，并利用这些特征实现人脸检测。</p>
<p>主流的人脸检测方法基于以上特征采用Adaboost学习算法，Adaboost算法是一种用来分类的方法，它把一些比较弱的分类方法合在一起，组合出新的很强的分类方法。</p>
<p>人脸检测过程中使用Adaboost算法挑选出一些最能代表人脸的矩形特征(弱分类器)，按照加权投票的方式将弱分类器构造为一个强分类器，再将训练得到的若干强分类器串联组成一个级联结构的层叠分类器，有效地提高分类器的检测速度。</p>
<h2 id="2-2-人脸图像预处理"><a href="#2-2-人脸图像预处理" class="headerlink" title="2.2 人脸图像预处理"></a>2.2 人脸图像预处理</h2><p>人脸图像预处理：对于人脸的图像预处理是基于人脸检测结果，对图像进行处理并最终服务于特征提取的过程。系统获取的原始图像由于受到各种条件的限制和随机干扰，往往不能直接使用，必须在图像处理的早期阶段对它进行灰度校正、噪声过滤等图像预处理。对于人脸图像而言，其预处理过程主要包括人脸图像的光线补偿、灰度变换、直方图均衡化、归一化、几何校正、滤波以及锐化等。</p>
<h2 id="2-3-人脸图像特征提取"><a href="#2-3-人脸图像特征提取" class="headerlink" title="2.3 人脸图像特征提取"></a>2.3 人脸图像特征提取</h2><p>人脸图像特征提取：人脸识别系统可使用的特征通常分为视觉特征、像素统计特征、人脸图像变换系数特征、人脸图像代数特征等。人脸特征提取就是针对人脸的某些特征进行的。人脸特征提取，也称人脸表征，它是对人脸进行特征建模的过程。</p>
<h2 id="2-4-人脸图像匹配与识别"><a href="#2-4-人脸图像匹配与识别" class="headerlink" title="2.4 人脸图像匹配与识别"></a>2.4 人脸图像匹配与识别</h2><p>人脸图像匹配与识别：提取的人脸图像的特征数据与数据库中存储的特征模板进行搜索匹配，通过设定一个阈值，当相似度超过这一阈值，则把匹配得到的结果输出。人脸识别就是将待识别的人脸特征与已得到的人脸特征模板进行比较，根据相似程度对人脸的身份信息进行判断。这一过程又分为两类：一类是确认，是一对一进行图像比较的过程，另一类是辨认，是一对多进行图像匹配对比的过程。</p>
<h1 id="3-人脸识别程序实现"><a href="#3-人脸识别程序实现" class="headerlink" title="3 人脸识别程序实现"></a>3 人脸识别程序实现</h1><h2 id="3-1-人脸图像采集及检测"><a href="#3-1-人脸图像采集及检测" class="headerlink" title="3.1 人脸图像采集及检测"></a>3.1 人脸图像采集及检测</h2><p><strong>人脸保存</strong>。新建目录 newface，用来保存人脸，代码奉上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def find_dir(Person_name):</span><br><span class="line">    # 读取目录</span><br><span class="line">    findfile = os.listdir(&quot;newface&quot;)</span><br><span class="line">    # 转列表 然后从新排序</span><br><span class="line">    list = []</span><br><span class="line">    for i in findfile:</span><br><span class="line">        list.append(int(i.split(&apos;_&apos;)[0]))</span><br><span class="line">    list.sort()  # 大小排序</span><br><span class="line">    # 判断目录是否为空 ，空写入0 否则按照顺序添加</span><br><span class="line">    if list == []:</span><br><span class="line">        os.mkdir(&apos;newface/0_%s&apos; % Person_name)</span><br><span class="line">        folder_number = &apos;0&apos;</span><br><span class="line">    else:</span><br><span class="line">        # 目录不为空，直接添加</span><br><span class="line">        folder_number = str(int(list[-1]) + 1)</span><br><span class="line">        os.mkdir(&apos;newface/%s_%s&apos; % (folder_number, Person_name))</span><br><span class="line">    return folder_number</span><br></pre></td></tr></table></figure>

<p>find_dir函数：在newface文件夹下生成以人名命名的文件夹，文件下保存该人的人脸</p>
<p><strong>人脸采集。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 收集人脸</span><br><span class="line">def collect_face():</span><br><span class="line">    # 导入识别人脸模块</span><br><span class="line">    faceModel= cv2.CascadeClassifier(&apos;face.xml&apos;)</span><br><span class="line">    # 打开摄像头收集人脸</span><br><span class="line">    # VideoCapture  0表示本地摄像头，1表示外部摄像头</span><br><span class="line">    capture = cv2.VideoCapture(0)</span><br><span class="line">    # 输入识别人的姓名</span><br><span class="line">    PersonName = input(&apos;请输入姓名:--&gt;&apos;)</span><br><span class="line">    FolderName = find_dir(PersonName)</span><br><span class="line">    # 定义变量，后面要用</span><br><span class="line">    counter = 0</span><br><span class="line">    Number_samples = 20</span><br><span class="line">    sleep(2)</span><br><span class="line">    while True:</span><br><span class="line">        # 读取摄像头数据，ret=ture or false 表示是否有人脸，frame是一帧一帧的图片</span><br><span class="line">        ret, frame = capture.read()</span><br><span class="line">        #灰度化图片，face.xml识别的是灰度图像中的人脸</span><br><span class="line">        gray = cv2.cvtColor(src=frame, code=cv2.COLOR_RGB2GRAY)</span><br><span class="line">        # 检测人脸 给我了一个坐标</span><br><span class="line">        faces = faceModel.detectMultiScale(frame, scaleFactor=1.2, minSize=(200, 200))</span><br><span class="line">        # 标记人脸&amp;取图片</span><br><span class="line">        for (x, y, w, h) in faces:</span><br><span class="line">            #记数，记录采集的图片的数目</span><br><span class="line">            counter += 1</span><br><span class="line">            #画摄像头人脸边框</span><br><span class="line">            cv2.rectangle(frame, pt1=(x, y), pt2=(x + w, y + h), color=(0, 255, 0), thickness=2)</span><br><span class="line">            #保存图片</span><br><span class="line">            counter=str(counter)</span><br><span class="line">            final_name = &apos;newface/&apos; + FolderName + &apos;_&apos; + PersonName + &apos;/&apos; + FolderName + &apos;_&apos; + &apos;%s.jpg&apos; % str(</span><br><span class="line">                PersonName + &apos;_&apos; + counter)</span><br><span class="line">            counter = int(counter)</span><br><span class="line">            SaveImg = Image.fromarray(gray)  # PIL直接读取 数组 然后存图片</span><br><span class="line">            SaveImg.save(fp=final_name)</span><br><span class="line">            Img = Image.open(fp=final_name)</span><br><span class="line">            # 截取头像 需要适当加大截取框</span><br><span class="line">            CropImg = Img.crop((x - 40, y - 40, x + w + 40, y + h + 40))  </span><br><span class="line">            CropImg.save(fp=final_name)</span><br><span class="line">            #显示采集的图片数目</span><br><span class="line">            cv2.putText(frame, &apos;%s Images collected&apos; % str(counter), org=(x, y - 10), fontScale=1,fontFace=cv2.FONT_HERSHEY_COMPLEX, color=(0, 255, 0), thickness=1)</span><br><span class="line">            #显示图片</span><br><span class="line">            cv2.imshow(&apos;LIVEface&apos;, frame)</span><br><span class="line">        # 如果已经收到足够量的样本就停</span><br><span class="line">        if counter &gt; Number_samples:</span><br><span class="line">            break</span><br><span class="line">        # 或者x退出</span><br><span class="line">        if cv2.waitKey(40) &amp; 0xFF == ord(&apos;x&apos;):</span><br><span class="line">            break</span><br><span class="line">    capture.release()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>代码中face.xml文件为cv2\data\haarcascade_frontalface_default.xml文件，我这里直接拿出来了。</p>
<p>代码中sheep（2）,打开机器的摄像头需要点时间，休眠等待下。</p>
<p>collect_face函数：用来收集人脸。采集人脸的方法有很多，基于图像处理和深度学习算法都可以用来采集人脸，但我做的效果都没有cv2自带的好，这里就直接用cv2中现有的算法采集人脸。</p>
<h2 id="3-2-人脸图像预处理"><a href="#3-2-人脸图像预处理" class="headerlink" title="3.2 人脸图像预处理"></a>3.2 人脸图像预处理</h2><p>将采集到的图像处理为相同大小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_dir</span><span class="params">(address)</span>:</span></span><br><span class="line">    <span class="comment"># 读取目录</span></span><br><span class="line">    filepath = <span class="string">'D:\\pycharm projects\\OpenCV\\wj\\newface'</span></span><br><span class="line">    fileNames = os.listdir(filepath)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> fileNames:</span><br><span class="line">        newDir = filepath + <span class="string">'/'</span> + file</span><br><span class="line">        path = newDir</span><br><span class="line">        fileNames_1 = os.listdir(path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> fileNames_1:</span><br><span class="line">            img = cv2.imread(path+<span class="string">'/'</span>+i,<span class="number">0</span>)</span><br><span class="line">            pic = cv2.resize(img, (<span class="number">200</span>, <span class="number">200</span>), interpolation=cv2.INTER_CUBIC)</span><br><span class="line">            final_name = <span class="string">'train_folder/'</span> +i</span><br><span class="line"></span><br><span class="line">            SaveImg = Image.fromarray(pic)  <span class="comment"># PIL直接读取 数组 然后存图片</span></span><br><span class="line">            SaveImg.save(fp=final_name)</span><br></pre></td></tr></table></figure>

<p>find_dir函数：将采集到的人脸图像处理为200*200大小。</p>
<p>3.3 人脸图像的特征提取与模型训练。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readImages</span><span class="params">()</span>:</span></span><br><span class="line">    x, y = [], []</span><br><span class="line">    filepath = <span class="string">r'D:\pycharm projects\OpenCV\wj\train_folder'</span></span><br><span class="line">    fileNames = os.listdir(filepath)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> fileNames:</span><br><span class="line">        newDir =filepath+<span class="string">"\\"</span>+file</span><br><span class="line">        img = cv2.imread(newDir, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">        img = cv2.resize(img, (<span class="number">200</span>, <span class="number">200</span>))</span><br><span class="line">        x.append(np.asarray(img, dtype=np.uint8)) <span class="comment">#x是训练数据</span></span><br><span class="line">        y.append(int(file.split(<span class="string">'_'</span>)[<span class="number">0</span>]))         <span class="comment">#y是训练数据标签</span></span><br><span class="line"></span><br><span class="line">    y = np.asarray(y, dtype=np.int32)</span><br><span class="line">    <span class="keyword">return</span> x, y</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#模型训练与保存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">face_rec</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取数据</span></span><br><span class="line">    x, y = readImages()</span><br><span class="line">    <span class="comment"># print(x[0].shape)</span></span><br><span class="line">    <span class="comment"># 人脸识别的模型</span></span><br><span class="line">    model = cv2.face.EigenFaceRecognizer_create()</span><br><span class="line">    <span class="comment"># fisherfaces算法的模型</span></span><br><span class="line">    <span class="comment"># model = cv2.face.FisherFaceRecognizer_create()</span></span><br><span class="line">    <span class="comment"># LBPH算法的模型</span></span><br><span class="line">    <span class="comment"># model = cv2.face.LBPHFaceRecognizer_create()</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Eigenfaces和Fisherfaces 预测时候产生0到20000的评分</span></span><br><span class="line"><span class="string">        低于4000 5000 的评分都是相当可靠的</span></span><br><span class="line"><span class="string">    LBPH 产生评分不同，低于50是可靠的 高于80是不可靠的</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练模型</span></span><br><span class="line">    model.train(np.asarray(x), np.asarray(y))</span><br><span class="line">    <span class="comment">#model.save("facemodel.txt")</span></span><br></pre></td></tr></table></figure>

<p>这里模型同样用的cv2现有的模型，感兴趣的可以尝试fisherfaces算法的模型和LBPH算法的模型。</p>
<p>3.4 人脸识别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">orc</span><span class="params">(model)</span>:</span></span><br><span class="line">    faceModel = cv2.CascadeClassifier(<span class="string">'face.xml'</span>)</span><br><span class="line">    capture = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 读取摄像头内容</span></span><br><span class="line">        ret, frame = capture.read()</span><br><span class="line">        <span class="comment"># 3维数据变一维</span></span><br><span class="line">        gray = cv2.cvtColor(src=frame, code=cv2.COLOR_RGB2GRAY)</span><br><span class="line">        <span class="comment"># 检测人脸</span></span><br><span class="line">        faces = faceModel.detectMultiScale(gray, scaleFactor=<span class="number">1.2</span>)</span><br><span class="line">        <span class="comment"># 标记人脸</span></span><br><span class="line">        <span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">            cv2.rectangle(frame, pt1=(x, y), pt2=(x + w, y + h), color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">2</span>)</span><br><span class="line">            SaveImg = Image.fromarray(gray) <span class="comment"># PIL直接读取 数组</span></span><br><span class="line">            SaveImg=np.array(SaveImg)</span><br><span class="line">            <span class="comment">#图片大小处理</span></span><br><span class="line">            pic = cv2.resize(SaveImg, (<span class="number">200</span>, <span class="number">200</span>), interpolation=cv2.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line">            a=int(model.predict(pic)[<span class="number">0</span>])</span><br><span class="line">            laber=[<span class="string">'wangjie'</span>,<span class="string">'wangkailun'</span>,<span class="string">'fengjingbao'</span>]</span><br><span class="line">            cv2.putText(frame, laber[a], (x, y), cv2.FONT_HERSHEY_SCRIPT_SIMPLEX, <span class="number">1</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">            cv2.imshow(<span class="string">'face'</span>, frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xff</span> == ord(<span class="string">'x'</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    capture.release()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>orc函数为人脸识别，传入的model为3.3中保存的模型，最后效果如下图。</p>
<p><img src="https://blog-1300775928.cos.ap-chengdu.myqcloud.com/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/image-20191125220743144.png" alt=""></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>java环境配置</title>
    <url>/2019/11/24/java%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="java环境配置"><a href="#java环境配置" class="headerlink" title="java环境配置"></a>java环境配置</h1><h2 id="1-jdk1-8下载"><a href="#1-jdk1-8下载" class="headerlink" title="1.jdk1.8下载"></a>1.jdk1.8下载</h2><a id="more"></a>

<p>下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<p>1.1 打开链接如图，点击Downloads。</p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574519694569.png" alt="1574519694569"></p>
<p><strong>1.2 网页下翻，找到Java SE Development Kit 8u231,点击接受License Agreement后找到对应jdk版本下载</strong>.</p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574520000241.png" alt="1574520000241"></p>
<h2 id="2-jdk1-8安装"><a href="#2-jdk1-8安装" class="headerlink" title="2.jdk1.8安装"></a>2.jdk1.8安装</h2><p><strong>2.1 解压刚下载的文件后打开，会出现如下窗口，安装Java SE，直接点击下一步。</strong></p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574520521565.png" alt="1574520521565"></p>
<p><strong>2.2 选择安装目录，后点击下一步。</strong></p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574520735939.png" alt="1574520735939"></p>
<p><strong>2.3  java SE 安装完后回弹出窗口java安装</strong>。选择安装位置，点击下一步</p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574521068513.png" alt="1574521068513"></p>
<p><strong>2.4 等待安装完成即可。</strong></p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574521148433.png" alt="1574521148433"></p>
<h2 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3 环境配置"></a>3 环境配置</h2><p><strong>3.1 进入系统的环境变量，点击环境变量</strong>。</p>
<p>（鼠标<strong>右键</strong>我的电脑，点击<strong>属性</strong>后点击 <strong>高级系统设置</strong>）</p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574522143475.png" alt="1574522143475"></p>
<p><strong>3.2  配置变量一  ：JAVA_HOMR(jdk安装的所在位置）</strong></p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574522346666.png" alt="1574522346666"></p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574522498231.png" alt="1574522498231"></p>
<p><strong>3.3 配置变量二 PATH 。</strong></p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574522620953.png" alt="1574522620953"></p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574522995349.png" alt="1574522995349"></p>
<p><strong>3.4 配置变量三 CLASSPATH</strong></p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574523141637.png" alt="1574523141637"></p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574523307793.png" alt="1574523307793"></p>
<p><strong>3.5 测试是否成功</strong></p>
<p>运行框中输入cmd ，后在dos窗口输入javac，出现下图则恭喜配置成功。</p>
<p><img src="C:%5CUsers%5Cwj123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1574523438453.png" alt="1574523438453"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
